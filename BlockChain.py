import hashlib
import json
from time import time # time() return unix time
from uuid import uuid4
from urllib.parse import urlparse
import requests

class Blockchain(object):
	"""
	The very first class to define a blockchian 
	"""
	def __init__(self):
		self.chain = []
		self.currentTransactions = []

		# The very first block --- the genesis
		self.newBlock(previous_hash=1, proof=100)

		# The set that contains all known nodes
		self.nodes = set()


	def newBlock(self, proof, previous_hash=None):
		# Create a new block and add the block to the chain
		# A block contains: index, timestamp, list of transactions, proof, previous hash
        # :param proof: <int> Proof of work generated by the algorithm
        # :param previous_hash: (Optional) <str> Hash of the previous block
        # :return: <dict> The new block generated
		
		block = {
			'index': len(self.chain) + 1,
			'timestamp': time(),
			'transactions': self.currentTransactions,
			'proof': proof,
			'previous_hash': previous_hash or self.hash(self.chain[-1]),
		}

		# Reset the current transaction records
		self.currentTransactions = []
		self.chain.append(block)
		return block


	def newTransaction(self, sender, recipient, amount):
		# Add a new transaction to the list of transactions
        # :param sender: <str> Address of the sender
        # :param recipient: <str> Address of the recipient
        # :param amount: <int> Amount
        # :return: <int> The index of the Block that will hold this transaction
		
		self.currentTransactions.append({
			'sender': sender,
			'recipient': recipient,
			'amount': amount,
			})

		return self.lastBlock['index'] + 1


	@staticmethod
	def hash(block):
		# Return the hash result of a block using SHA256
		# :param block: <dict> Block
        # :return: <str>
		block_string = json.dumps(block, sort_keys=True).encode()
		return hashlib.sha256(block_string).hexdigest()


	@property
	def lastBlock(self):
		# Return the last block in the chain
		return self.chain[-1]


	def proof_of_work(self, last_proof):
        # Simple Proof of Work Algorithm:
        #  - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p'
        #  - p is the previous proof, and p' is the new proof
        # :param last_proof: <int>
        # :return: <int>
		proof = 0
		while self.valid_proof(last_proof, proof) is False:
			proof += 1
		return proof


	@staticmethod
	def valid_proof(last_proof, proof):
        # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?
        # :param last_proof: <int> Previous Proof
        # :param proof: <int> Current Proof
        # :return: <bool> True if correct, False if not.

		num_zeros = 4

		guess = f'{last_proof}{proof}'.encode()  # f'{var}' syntax only works for Python 3.6+
		guess_hash = hashlib.sha256(guess).hexdigest()
		return guess_hash[0:num_zeros] == '0000'


	def registerNode(self, address):
		# Add a new node to the list of nodes
  		# :param address: <str> Address of node. Eg. 'http://192.168.0.5:5000'
		#:return: None

		parsed_url = urlparse(address)
		self.nodes.add(parsed_url.netloc)


	def valid_chain(self, chain):
        # Determine if a given blockchain is valid
        # :param chain: <list> A blockchain
        # :return: <bool> True if valid, False if not		

		lastBlock = chain[0]
		currentIndex = 1

		while currentIndex < len(chain):
			block = chain[currentIndex]
			print(f'{lastBlock}')
			print(f'{block}')
			print("\n------------\n")

			# Check that the hash of the block is correct
			if block['previous_hash'] != self.hash(lastBlock):
				return False

			# Check the Proof of Work is correct
			if not self.valid_proof(lastBlock['proof'], block['proof']):
				return False

			lastBlock = block
			currentIndex += 1

		return True

	def resolve_conflicts(self):
        # This is our Consensus Algorithm, it resolves conflicts
        # by replacing our chain with the longest one in the network.
        # :return: <bool> True if our chain was replaced, False if not
		neighbours = self.nodes
		newChain = None

		maxLength = len(self.chain)

		for node in neighbours:
			response = requests.get(f'http://{node}/chain')

			if response.status_code == 200:
				length = response.json()['length']
				chain = response.json()['chain']


				if length > maxLength and self.valid_chain(chain):
					newChain = chain

		if newChain:
			self.chain = newChain
			return True
		return False










