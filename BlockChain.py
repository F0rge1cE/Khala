import hashlib
import json
from time import time # time() return unix time
from uuid import uuid4

class Blockchain(object):
	"""
	The very first class to define a blockchian 
	"""
	def __init__(self):
		self.chain = []
		self.currentTransactions = []

		# The very first block --- the genesis
		self.newBlock(previous_hash=1, proof=100)


	def newBlock(self, previous_hash=None, proof):
		# Create a new block and add the block to the chain
		# A block contains: index, timestamp, list of transactions, proof, previous hash
        # :param proof: <int> Proof of work generated by the algorithm
        # :param previous_hash: (Optional) <str> Hash of the previous block
        # :return: <dict> The new block generated
		
		block = {
			'index' = len(self.chain) + 1
			'timestamp' = time()
			'transactions' = self.currentTransactions
			'proof' = proof
			'previous_hash' = previous_hash or self.hash(self.chain[-1]),
		}

		# Reset the current transaction records
		self.currentTransactions = []

		self.chain.append(block)
		return block


	def newTransaction(self, sender, recipient, amount):
		# Add a new transaction to the list of transactions
        # :param sender: <str> Address of the sender
        # :param recipient: <str> Address of the recipient
        # :param amount: <int> Amount
        # :return: <int> The index of the Block that will hold this transaction
		
		self.currentTransactions.append({
			'sender': sender,
			'recipient': recipient,
			'amount': amount,
			})

		return self.lastBlock['index'] + 1


	@staticmethod
	def hash(block):
		# Return the hash result of a block
		pass


	@property
	def lastBlock(self):
		# Return the last block in the chain
		return self.chain[-1]


	def proof_of_work(self, last_proof):
        # Simple Proof of Work Algorithm:
        #  - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p'
        #  - p is the previous proof, and p' is the new proof
        # :param last_proof: <int>
        # :return: <int>

        proof = 0
        while self.valid_proof(last_proof, proof) is False:
        	proof += 1
        return proof


    @staticmethod
	def valid_proof(last_proof, proof):
        # Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes?
        # :param last_proof: <int> Previous Proof
        # :param proof: <int> Current Proof
        # :return: <bool> True if correct, False if not.
        num_zeros = 4

        guess = f'{last_proof}{proof}'.encode()  # f'{var}' syntax only works for Python 3.6+
        guess_hash = hashlib.sha256(guess).hexdigest()
        return guess_hash[0:num_zeros] = '0000'






